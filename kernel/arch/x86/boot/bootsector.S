#include "asm.h"

.set PROT_MODE_CSEG, 0x8	# kernel code segment selector	GDT的第二个
.set PROT_MODE_DSEG, 0x10	# kernel data segment selector	GDT的第三个
.set CR0_PE_ON,	0x01		# protected mode enable flag

#########################################################################
# ENTRY POINT for the bootstrap processor
# This code should be stored in the first sector of the hard disk.
# After the BIOS initializes the hardware on startup or system reset,
# it loads this code at physical address 0x7c00 - 0x7d00 (512 bytes).
# Then the BIOS jumps to the beginning of it, address 0x7c00,
# while running in 16-bit real-mode (8086 compatibility mode).
# The Code Segment register (CS) is initially zero on entry.
#
# This code switches into 32-bit protected mode so that all of
# memory can accessed, then calls into C.
#########################################################################

.globl start				# Entry point
start:
.code16						# This runs in real mode
	cli						# Disable interrupts
	cld						# String operations increment

	# Set up the important data segment registers (DS, ES, SS)
	xorw	%ax, %ax		# Segment number zero
	movw	%ax, %ds		# -> Data Segment
	movw	%ax, %es		# -> Extra Segment
	movw	%ax, %ss		# -> Stack Segment

	# Set up the stack pointer, growing downward from 0x7c00
	movw	$start, %sp		# Stack Pointer

	# Enable A20:
	# For fascinating historical reasons (related to the fact that
	# the earliest 8086?based PCs could only address 1MB of physical
	# memory and subsequent 80286?based PCs wanted to retain maximum
	# compatibility), physical address line 20 is tied to low when the
	# machine boots. Obviously this a bit of a drag for us, especially
	# when trying to address memory above 1MB. This code undoes this.

seta20.1:
	inb		$0x64, %al		# Get status
	testb	$0x02, %al		# Busy?
	jnz		seta20.1		# Yes
	movb	$0xd1, %al		# Command: Write
	outb	%al, $0x64		# Output port

seta20.2:
	inb		$0x64, %al		# Get status
	testb	$0x02, %al		# Busy?
	jnz		seta20.2		# Yes
	movb	$0xdf, %al		# Enable
	outb 	%al, $0x60		# A20

	# Switch from real to protected mode
	# The descriptors in our GDT allow all physical memory to be accessed.
	# Furthermore, the descriptors have base addresses of 0, so that the
	# segment translation is a NOP, ie. virtual addresses are identical to
	# their physical addresses. With this setup, immediately after
	# enabling protected mode it will still appear to this code
	# that it is running directly on physical memory with no translation.
	# This initial NOP-translation setup is required by the processor
	# to ensure that the transition to protected mode occurs smoothly.

real_2_protect:
	cli							# Mandatory since we donot set up an IDT
	lgdt	gdtdesc				# load GDT -- mandatory in protected mode
	movl	%cr0, %eax			#
	orl		$CR0_PE_ON, %eax	# turn on protected mode
	movl	%eax, %cr0			#

	### CPU magic: jump to relocation, flush prefetch queue, and reload %cs
	### Has the effect of just jmp to the next instruction, but simultaneous
	### loads CS with $PROT_MODE_CSEG.
	ljmp	$PROT_MODE_CSEG, $protected_mode

	#### we are in 32-bit protected mode (hence the .code32)
.code32
protected_mode:
	# Set up the protected?mode data segment registers
	movw	$PROT_MODE_DSEG, %ax				# Our data segment selector
	movw	%ax, %ds							# -> DS: Data Segment
	movw	%ax, %es							# -> ES: Extra Segment
	movw	%ax, %fs							# -> FS
	movw	%ax, %gs							# -> GS
	movw	%ax, %ss							# -> SS: Stack Segment

	movl    $start, %esp						# Set up the stack pointer and call into C.
	call	load								# finish the boot load from C.

	# load() should not return

spin:
	jmp		spin									# ..but in case it does, spin

.p2align 2 											# force 4 byte alignment
gdt:
	NULL_SEGMENT_DESCRIPTOR 									# null seg
	DEFINE_SEGMENT_DESCRIPTOR(STA_X | STA_R, 0x00, 0xffffffff) 	# code seg
	DEFINE_SEGMENT_DESCRIPTOR(STA_W, 0x00, 0xffffffff) 			# data seg
gdtdesc:
	.word 0x17 										# sizeof(gdt) - 1
	.long gdt 										# address gdt
